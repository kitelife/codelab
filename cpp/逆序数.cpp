/*4. 计算逆序对的数目

问题描述

Sort公司是一个专门为人们提供排序服务的公司，该公司的宗旨是：“顺序是最美丽的”。他们的工作是通过一系列移动，将某些物品按顺序摆好。他们的服务是通过工作量来计算的，即移动东西的次数。所以，在工作前必须先考察工作量，以便向用户提出收费数目。

假设我们将序列中第i件物品的参数定义为Ai，那么，排序就是指将A数组从小到大排序。用户并不需要知道精确的移动次数，实质上，大多数人都是凭感觉来认定这一列物品的混乱程度，根据Sort公司的经验，人们一般是根据“逆序对”的数目多少来称呼这一序列的混乱程度。

若数组A的元素A1,…,An互不相同，所谓数组A的“逆序对”是指，若i<j且Ai>Aj，则<i,j>就为一个“逆序对”。请你为Sort公司做一个程序，在尽量短的时间内，统计出"逆序对"的数目。

输入

输入有若干行，每两行对应一种情形。两行中的第一行为一个整数n（1≤n≤10000），接下来一行为n个互不相同的整数。

输入直到文件输入结束。

输出

对每一种情形的测试数据，在一行上先输出“Case #:”，其中“#”是测试数据集的编号（从1开始），接着在下面的输出结果。不同数据集的结果之间空一行。

输入样例 

5
3 1 4 5 2
6
1 2 3 4 5 6
7
7 6 5 4 3 2 1
输出样例

Case 1:
4

 

Case 2:

0


Case 3:

21
*/
#include<iostream>
#define maxsize 10000 
using namespace std;
int main()
{
    int i,x,y,z;
    int shuzu[maxsize];
    y=0;
    z=0;
    while(cin>>i)
    {
                 z++;
                 for(int j=0;j<i;j++)
                 {
                         cin>>x;
                         shuzu[j]=x;     
                 }
                 for(int k=0;k<i;k++)
                 {
                         for(int p=k+1;p<i;p++)
                         {
                                 if(shuzu[k]>shuzu[p])
                                 y++;
                         }  
                 } 
    cout<<"case "<<z<<":"<<endl;
    cout<<y<<endl;
    cout<<endl;
    y=0;
    }
    return 0;
}

